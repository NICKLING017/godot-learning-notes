# 输入映射配置

> Godot 4 输入系统详解，支持键盘、鼠标、手柄的多平台输入配置

## 目录
- [输入系统概述](#输入系统概述)
- [项目输入配置分析](#项目输入配置分析)
- [InputMap 详解](#inputmap-详解)
- [多平台输入支持](#多平台输入支持)
- [输入处理最佳实践](#输入处理最佳实践)
- [扩展输入功能](#扩展输入功能)
- [调试与测试](#调试与测试)

## 输入系统概述

### Godot 输入处理流程
```
输入设备 → 输入事件 → 输入映射 → 游戏逻辑
    ↓          ↓           ↓          ↓
键盘/鼠标/手柄 → InputEvent → InputMap → is_action_pressed()
```

### 核心概念
| 概念 | 描述 | 示例 |
|------|------|------|
| **输入事件** | 具体的输入操作 | 按键按下、鼠标点击、手柄摇杆 |
| **输入动作** | 抽象的游戏操作 | "move_up"、"shoot"、"jump" |
| **输入映射** | 事件与动作的关联 | W键 → "move_up" |
| **死区** | 避免误触的阈值 | 手柄摇杆死区 0.2 |

## 项目输入配置分析

### project.godot 输入配置
```gdscript
# 从 project.godot 提取的输入配置
[input]

up={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}

down={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}

left={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}

right={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}

shoot={
"deadzone": 0.2,
"events": [Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":1,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
```

### 配置解析

#### 1. 移动控制（WASD）
| 动作 | 物理键码 | 对应按键 | Unicode | 功能 |
|------|----------|----------|---------|------|
| up | 87 | W | 119 | 向上移动 |
| down | 83 | S | 115 | 向下移动 |
| left | 65 | A | 97 | 向左移动 |
| right | 68 | D | 100 | 向右移动 |

**技术细节**：
- `physical_keycode`: 物理键码，与键盘布局无关
- `keycode`: 逻辑键码（当前为0，使用物理键码）
- `unicode`: 对应的Unicode字符
- `location`: 键位位置（0=标准，1=左，2=右）

#### 2. 射击控制（鼠标左键）
```gdscript
shoot={
"deadzone": 0.2,
"events": [Object(InputEventMouseButton,
    "button_index": 1,  # 鼠标左键
    "pressed": false,   # 按下状态
    "double_click": false
)]
}
```

**鼠标按钮索引**：
- 1: 左键
- 2: 右键
- 3: 中键
- 4: 滚轮上
- 5: 滚轮下

#### 3. 死区配置
```gdscript
"deadzone": 0.2  # 20%死区
```

**作用**：
- 防止手柄摇杆轻微移动误触发
- 过滤噪声输入
- 提高输入精度

## InputMap 详解

### 什么是 InputMap？
`InputMap` 是 Godot 的全局输入映射管理器，负责：
1. 定义抽象输入动作
2. 绑定具体输入事件
3. 管理多设备输入
4. 提供统一的输入查询接口

### 基本用法
```gdscript
# 1. 检查动作是否存在
if InputMap.has_action("shoot"):
    print("shoot动作已定义")

# 2. 添加新动作
InputMap.add_action("special_attack")

# 3. 添加输入事件
var key_event = InputEventKey.new()
key_event.keycode = KEY_SPACE
InputMap.action_add_event("jump", key_event)

# 4. 移除输入事件
InputMap.action_erase_events("shoot")
```

### 项目中的 InputMap 使用
虽然当前项目主要在 project.godot 中配置，但代码中可能会动态修改：

```gdscript
# 动态添加触摸支持（类似Flappy Bird项目）
func _setup_touch_input() -> void:
    if InputMap.has_action("shoot"):
        var touch_event = InputEventScreenTouch.new()
        touch_event.index = -1  # 匹配任意手指
        touch_event.pressed = true  # 按下时触发
        InputMap.action_add_event("shoot", touch_event)
```

## 多平台输入支持

### 1. 键盘输入
```gdscript
# 检测按键
if Input.is_key_pressed(KEY_W):
    print("W键按下")

# 使用动作检测（推荐）
if Input.is_action_pressed("up"):
    position.y -= speed * delta
```

### 2. 鼠标输入
```gdscript
# 获取鼠标位置
var mouse_pos = get_global_mouse_position()

# 检测鼠标按钮
if Input.is_mouse_button_pressed(MOUSE_BUTTON_LEFT):
    print("鼠标左键按下")

# 鼠标移动事件
func _input(event: InputEvent):
    if event is InputEventMouseMotion:
        print("鼠标移动: ", event.relative)
```

### 3. 手柄输入
```gdscript
# 检测手柄连接
var joypad_count = Input.get_connected_joypads().size()

# 手柄按钮检测
if Input.is_joy_button_pressed(0, JOY_BUTTON_A):
    print("手柄A键按下")

# 手柄摇杆检测
var left_stick = Input.get_joy_axis(0, JOY_AXIS_LEFT_X)
var right_stick = Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)

# 使用动作检测（自动处理死区）
var move_vector = Input.get_vector("left", "right", "up", "down")
```

### 4. 触摸屏输入
```gdscript
# 触摸事件处理
func _input(event: InputEvent):
    if event is InputEventScreenTouch:
        if event.pressed:
            print("屏幕触摸: ", event.position)
            handle_touch(event.position)
        else:
            print("触摸释放")
    
    elif event is InputEventScreenDrag:
        print("触摸拖拽: ", event.position, " 相对移动: ", event.relative)
```

### 5. 通用输入处理
```gdscript
# 使用 Input.get_vector() 统一处理
func _process(delta: float):
    # 自动处理键盘、手柄、触摸的方向输入
    var direction = Input.get_vector("left", "right", "up", "down")
    
    if direction.length() > 0:
        # 移动角色
        position += direction * speed * delta
        
        # 更新朝向
        if direction.length() > 0.1:  # 避免微小移动
            rotation = direction.angle()
```

## 输入处理最佳实践

### 1. 使用抽象动作而非具体按键
```gdscript
# ❌ 不推荐：硬编码按键
if Input.is_key_pressed(KEY_W):
    move_up()

# ✅ 推荐：使用抽象动作
if Input.is_action_pressed("move_up"):
    move_up()
```

**优势**：
- 支持多输入设备
- 易于重新映射按键
- 提高代码可读性
- 便于国际化

### 2. 区分 pressed 和 just_pressed
```gdscript
# pressed(): 每帧触发，适合持续移动
if Input.is_action_pressed("move_right"):
    position.x += speed * delta

# just_pressed(): 单次触发，适合跳跃、射击
if Input.is_action_just_pressed("jump"):
    velocity.y = JUMP_FORCE

# just_released(): 释放时触发
if Input.is_action_just_released("shoot"):
    end_charging()
```

### 3. 输入缓冲技术
```gdscript
# 输入缓冲：存储最近的输入，提高响应性
var input_buffer: Array[String] = []
const BUFFER_DURATION = 0.2  # 200ms缓冲

func _process(delta: float):
    # 记录输入
    if Input.is_action_just_pressed("attack"):
        input_buffer.append("attack")
        get_tree().create_timer(BUFFER_DURATION).timeout.connect(
            func(): input_buffer.erase("attack")
        )
    
    # 检查缓冲输入
    if can_attack and "attack" in input_buffer:
        perform_attack()
        input_buffer.erase("attack")
```

### 4. 输入组合检测
```gdscript
# 组合键检测
func check_combo():
    var shift_pressed = Input.is_key_pressed(KEY_SHIFT)
    var ctrl_pressed = Input.is_key_pressed(KEY_CTRL)
    
    if Input.is_action_just_pressed("ability1"):
        if shift_pressed:
            use_enhanced_ability1()
        elif ctrl_pressed:
            use_quick_ability1()
        else:
            use_ability1()
```

### 5. 输入设备自动切换
```gdscript
# 检测当前使用的输入设备
enum InputDevice { KEYBOARD, MOUSE, GAMEPAD, TOUCH }
var current_device = InputDevice.KEYBOARD

func _input(event: InputEvent):
    # 检测设备切换
    if event is InputEventKey or event is InputEventMouseMotion:
        current_device = InputDevice.KEYBOARD
    elif event is InputEventJoypadButton or event is InputEventJoypadMotion:
        current_device = InputDevice.GAMEPAD
    elif event is InputEventScreenTouch or event is InputEventScreenDrag:
        current_device = InputDevice.TOUCH
    
    # 根据设备调整UI
    update_input_hints()

func update_input_hints():
    match current_device:
        InputDevice.KEYBOARD:
            $HUD.show_keyboard_hints()
        InputDevice.GAMEPAD:
            $HUD.show_gamepad_hints()
        InputDevice.TOUCH:
            $HUD.show_touch_hints()
```

## 扩展输入功能

### 1. 按键重映射系统
```gdscript
# 可配置的按键重映射
class RemappableInputSystem:
    var action_map: Dictionary = {}
    
    func _init():
        # 默认配置
        action_map = {
            "move_up": [KEY_W],
            "move_down": [KEY_S],
            "move_left": [KEY_A],
            "move_right": [KEY_D],
            "shoot": [MOUSE_BUTTON_LEFT]
        }
    
    func remap_action(action: String, new_key: int):
        if InputMap.has_action(action):
            # 清除旧映射
            InputMap.action_erase_events(action)
            
            # 添加新映射
            var event = InputEventKey.new()
            event.keycode = new_key
            InputMap.action_add_event(action, event)
            
            # 更新本地映射
            action_map[action] = [new_key]
    
    func save_mappings():
        var config = ConfigFile.new()
        for action in action_map.keys():
            config.set_value("input", action, action_map[action])
        config.save("user://input_config.cfg")
```

### 2. 触摸虚拟摇杆
```gdscript
# 虚拟摇杆实现
class VirtualJoystick:
    var touch_index: int = -1
    var center_pos: Vector2 = Vector2.ZERO
    var current_pos: Vector2 = Vector2.ZERO
    var radius: float = 100.0
    
    func _input(event: InputEvent):
        if event is InputEventScreenTouch:
            if event.pressed and touch_index == -1:
                # 开始触摸
                touch_index = event.index
                center_pos = event.position
                current_pos = center_pos
            elif not event.pressed and event.index == touch_index:
                # 结束触摸
                touch_index = -1
                current_pos = center_pos
        
        elif event is InputEventScreenDrag and event.index == touch_index:
            # 更新位置
            current_pos = event.position
            
            # 限制在圆形范围内
            var offset = current_pos - center_pos
            if offset.length() > radius:
                current_pos = center_pos + offset.normalized() * radius
    
    func get_direction() -> Vector2:
        if touch_index == -1:
            return Vector2.ZERO
        
        var offset = current_pos - center_pos
        return offset / radius  # 归一化方向
```

### 3. 手势识别
```gdscript
# 简单手势识别
class GestureRecognizer:
    var touch_start_pos: Vector2 = Vector2.ZERO
    var touch_start_time: float = 0.0
    var gesture_history: Array[Vector2] = []
    
    func _input(event: InputEvent):
        if event is InputEventScreenTouch:
            if event.pressed:
                touch_start_pos = event.position
                touch_start_time = Time.get_ticks_msec()
                gesture_history.clear()
            else:
                recognize_gesture(event.position)
        
        elif event is InputEventScreenDrag:
            gesture_history.append(event.position)
    
    func recognize_gesture(end_pos: Vector2):
        var duration = Time.get_ticks_msec() - touch_start_time
        var distance = touch_start_pos.distance_to(end_pos)
        
        # 识别滑动手势
        if duration < 300 and distance > 50:  # 300ms内移动50像素
            var direction = (end_pos - touch_start_pos).normalized()
            
            if abs(direction.x) > abs(direction.y):
                # 水平滑动
                if direction.x > 0:
                    emit_signal("swipe_right")
                else:
                    emit_signal("swipe_left")
            else:
                # 垂直滑动
                if direction.y > 0:
                    emit_signal("swipe_down")
                else:
                    emit_signal("swipe_up")
```

## 调试与测试

### 1. 输入事件监控
```gdscript
# 输入调试面板
func _input(event: InputEvent):
    # 记录所有输入事件
    if event is InputEventKey and event.pressed:
        print("按键: ", event.keycode, " pressed: ", event.pressed)
    
    elif event is InputEventMouseButton:
        print("鼠标按钮: ", event.button_index, " pressed: ", event.pressed)
    
    elif event is InputEventJoypadButton:
        print("手柄按钮: ", event.button_index, " pressed: ", event.pressed)
    
    elif event is InputEventJoypadMotion:
        if abs(event.axis_value) > 0.1:  # 过滤微小移动
            print("手柄摇杆: 轴", event.axis, " 值: ", event.axis_value)
```

### 2. 输入可视化
```gdscript
# 在屏幕上显示输入状态
func _draw():
    # 绘制当前输入方向
    var direction = Input.get_vector("left", "right", "up", "down")
    if direction.length() > 0:
        var center = Vector2(100, 100)
        var end = center + direction * 50
        draw_line(center, end, Color.GREEN, 3)
        draw_circle(end, 10, Color.RED)
    
    # 绘制按键状态
    var y_offset = 200
    for action in ["up", "down", "left", "right", "shoot"]:
        var color = Color.GREEN if Input.is_action_pressed(action) else Color.GRAY
        draw_string(get_theme_default_font(), Vector2(50, y_offset), 
                   action + ": " + str(Input.is_action_pressed(action)), 
                   HORIZONTAL_ALIGNMENT_LEFT, -1, 16, color)
        y_offset += 30
```

### 3. 输入响应测试
```gdscript
# 输入延迟测试
var input_timestamps: Dictionary = {}

func _input(event: InputEvent):
    var current_time = Time.get_ticks_usec()
    
    if event is InputEventKey and event.pressed:
        var key_name = OS.get_keycode_string(event.keycode)
        
        if key_name in input_timestamps:
            var last_time = input_timestamps[key_name]
            var delay_ms = (current_time - last_time) / 1000.0
            print("按键 ", key_name, " 响应延迟: ", delay_ms, "ms")
        
        input_timestamps[key_name] = current_time
```

### 4. 多设备兼容性测试
```gdscript
# 自动测试不同输入设备
func test_input_devices():
    print("=== 输入设备测试 ===")
    
    # 测试键盘
    print("键盘测试:")
    simulate_key_press(KEY_W)
    assert(Input.is_action_pressed("up"), "键盘W键应该触发up动作")
    
    # 测试鼠标
    print("鼠标测试:")
    simulate_mouse_click(MOUSE_BUTTON_LEFT)
    assert(Input.is_action_pressed("shoot"), "鼠标左键应该触发shoot动作")
    
    # 测试手柄（如果连接）
    var joypads = Input.get_connected_joypads()
    if joypads.size() > 0:
        print("手柄测试:")
        simulate_joypad_button(0, JOY_BUTTON_A)
        # 需要定义对应的动作映射
    
    print("=== 测试完成 ===")
```

## 总结

### 项目输入配置特点
1. **简洁的WASD控制**：符合PC游戏标准
2. **鼠标射击**：直观的瞄准与射击
3. **预留扩展性**：死区配置支持未来添加手柄

### 最佳实践建议
1. **始终使用InputMap**：避免硬编码按键
2. **区分输入类型**：正确使用 `pressed` 和 `just_pressed`
3. **支持多平台**：考虑键盘、鼠标、手柄、触摸屏
4. **提供重映射**：允许玩家自定义控制

### 扩展方向
1. **添加手柄支持**：完整的摇杆和按钮映射
2. **实现触摸控制**：虚拟摇杆和按钮
3. **输入重映射界面**：玩家可自定义按键
4. **输入反馈系统**：震动、音效、视觉反馈

### 学习收获
- 掌握 Godot 输入系统架构
- 理解抽象输入动作的重要性
- 学会多平台输入适配
- 实践输入调试和测试方法

---

*返回 [[欢迎|项目主页]]*