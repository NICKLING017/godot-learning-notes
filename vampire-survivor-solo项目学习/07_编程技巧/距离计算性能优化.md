# 距离计算性能优化

## 为什么需要优化

在游戏中经常需要计算距离（如索敌、范围检测），每秒可能执行数千次。

```
distance_to() = sqrt(x*x + y*y)  # 需要开方运算
distance_squared_to() = x*x + y*y # 仅乘法加法
```

开方运算比乘法慢 **10-100 倍**。

## 优化原则

### 1. 比较距离时用平方值

```gdscript
# ❌ 慢：开方
if enemy.global_position.distance_to(player.global_position) < attack_range:
    attack()

# ✅ 快：比较平方值
var attack_range_sq = attack_range * attack_range
if enemy.global_position.distance_squared_to(player.global_position) < attack_range_sq:
    attack()
```

### 2. 预计算平方值

```gdscript
# 在 _ready 或初始化时
const MAX_RANGE: float = 150.0
const MAX_RANGE_SQ: float = 150.0 * 150.0

func _process_enemies(enemies: Array[Node]) -> void:
    for enemy in enemies:
        # 直接使用预计算的平方值
        if enemy.global_position.distance_squared_to(player.global_position) < MAX_RANGE_SQ:
            # ...
```

### 3. 排序时用平方值

```gdscript
# ❌ 慢
enemies.sort_custom(func(a, b):
    return a.global_position.distance_to(player.global_position) < \
           b.global_position.distance_to(player.global_position)
)

# ✅ 快
enemies.sort_custom(func(a, b):
    return a.global_position.distance_squared_to(player.global_position) < \
           b.global_position.distance_squared_to(player.global_position)
)
```

## 性能对比

```gdscript
# 测试代码
var start = Time.get_ticks_msec()
for i in range(10000):
    var a = Vector2(randf(), randf()) * 1000
    var b = Vector2(randf(), randf()) * 1000
    a.distance_to(b)  # 或 distance_squared_to
var end = Time.get_ticks_msec()
print("耗时: ", end - start, "ms")
```

| 操作 | 相对耗时 |
|------|----------|
| distance_to() | 1x (基准) |
| distance_squared_to() | 0.1x (10倍快) |

## 何时不能用平方

```gdscript
# 需要真实距离值时，必须开方
var distance = enemy.global_position.distance_to(player.global_position)

# UI显示距离
distance_label.text = "距离: %.1f" % distance

# 归一化方向向量（需要单位向量）
var direction = (target - origin).normalized()  # 内部会开方
```

## 完整优化示例

```gdscript
extends Node2D

const ATTACK_RANGE: float = 120.0
const ATTACK_RANGE_SQ: float = 120.0 * 120.0  # 预计算

func find_targets() -> Array[Node2D]:
    var all_enemies = get_tree().get_nodes_in_group("enemy")
    var in_range: Array[Node2D] = []

    for enemy in all_enemies:
        # 优化：用平方比较
        if enemy.global_position.distance_squared_to(global_position) < ATTACK_RANGE_SQ:
            in_range.append(enemy)

    # 优化：用平方排序
    in_range.sort_custom(func(a, b):
        return a.global_position.distance_squared_to(global_position) < \
               b.global_position.distance_squared_to(global_position)
    )

    return in_range

func attack() -> void:
    var targets = find_targets()
    for target in targets:
        var distance = target.global_position.distance_to(global_position)  # 只在这里开方
        # 实际攻击逻辑...
```

## 最佳实践

1. **默认用平方** - 距离比较、排序、筛选都用 distance_squared_to
2. **预计算** - 常量平方值在初始化时计算
3. **最后开方** - 只有显示或需要单位向量时才开方
4. **变量命名** - _sq 后缀标记平方值
